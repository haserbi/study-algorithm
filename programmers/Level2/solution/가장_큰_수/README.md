# [가장 큰 수](https://programmers.co.kr/learn/courses/30/lessons/42746)

## 문제 설명

0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.

예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.

0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.

### 제한 사항

- numbers의 길이는 1 이상 100,000 이하입니다.
- numbers의 원소는 0 이상 1,000 이하입니다.
- 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.

### 입출력 예

|numbers|return|
|---|---|
|[6, 10, 2]|"6210"|
|[3, 30, 34, 5, 9]|"9534330"|

## 문제 풀이 리뷰

[Java](./solution.java)

문제는 Comparator 인터페이스를 이용하면 쉽게 풀 수 있다.  
Comparator와 Comparable은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있다.  
**Comparable**은 기본 정렬기준을 구현하는데 사용하며, **Comparator**는 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용한다.

문제풀이의 핵심은 배열의 서로 다른 숫자의 조합으로 가장 큰 수를 반환하는 문제이다.

그렇기 때문에 배열들을 비교하여 가장 큰 수를 찾아서 출력해주면 되는 것이다.
Comparator 인터페이스안의 compareTo함수를 재정의 하여 문제를 풀이 하였는데 해당 comapreTo가 어떻게 돌아가는지 궁금하여 출력함수를 이용해보았다.

compareTo함수는 재귀적으로 호출하며 기존값과 비교하려는 대상의 값이 큰 경우 서로의 위치를 변환하는 것 같았다.

실제로 확인하기 위해 입출력예제의 [3, 30, 34, 5, 9]와 정렬된 값 [9, 5, 34, 3, 30]을 출력함수로 확인해보았다.  
![image](./images/image.png)

첫번째의 경우 총 9번의 비교를 하는데 small인경우 위치를 변경하고, big은 그대로라고 판정하였다.  
1: [3, 30]  
2: [3, 34, 30]  
3: [3, 34, 30] (이 부분을 왜 한번 체크하는지 아직 모르겠다.)
4: [34, 3, 30]  
5: [34, 5, 3, 30]  
6: [5, 34, 3, 30]  
7: [5, 9, 34, 3, 30]  
8: [9, 5, 34, 3, 30]  
이렇게해서 9534330 이 나온다.

두번째의 경우는 이미 정렬을 예측하고 넣었기 때문에 4번의 비교를 한다.  
1: [9, 5]  
2: [9, 5, 34]  
3: [9, 5, 34, 3]  
4: [9, 5, 34, 3, 30]  
이렇게해서 9534330이 나온다.

위의 경우는 String 타입의 조건으로 정렬은 한 경우이며, 같은 타입의 인스턴스 끼리도 비교가 가능하다.  
이는 java util 함수내부에서 최적의 조건으로 정렬하는 것이라 생각된다.  

해당 문제를 풀고 기초적인 공부의 필요성에 대해 생각하게 됐으며, 알고리즘 공부와 함께 기초서적 공부를 해야겠다.  