# 풀이 리뷰

문제는 Comparator 인터페이스를 이용하면 쉽게 풀 수 있다.  
Comparator와 Comparable은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있다.  
**Comparable**은 기본 정렬기준을 구현하는데 사용하며, **Comparator**는 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용한다.

문제풀이의 핵심은 배열의 서로 다른 숫자의 조합으로 가장 큰 수를 반환하는 문제이다.

그렇기 때문에 배열들을 비교하여 가장 큰 수를 찾아서 출력해주면 되는 것이다.
Comparator 인터페이스안의 compareTo함수를 재정의 하여 문제를 풀이 하였는데 해당 comapreTo가 어떻게 돌아가는지 궁금하여 출력함수를 이용해보았다.

compareTo함수는 재귀적으로 호출하며 기존값과 비교하려는 대상의 값이 큰 경우 서로의 위치를 변환하는 것 같았다.

실제로 확인하기 위해 입출력예제의 [3, 30, 34, 5, 9]와 정렬된 값 [9, 5, 34, 3, 30]을 출력함수로 확인해보았다.  
![image](./images/image.png)

첫번째의 경우 총 9번의 비교를 하는데 small인경우 위치를 변경하고, big은 그대로라고 판정하였다.  
1: [3, 30]  
2: [3, 34, 30]  
3: [3, 34, 30] (이 부분을 왜 한번 체크하는지 아직 모르겠다.)
4: [34, 3, 30]  
5: [34, 5, 3, 30]  
6: [5, 34, 3, 30]  
7: [5, 9, 34, 3, 30]  
8: [9, 5, 34, 3, 30]  
이렇게해서 9534330 이 나온다.

두번째의 경우는 이미 정렬을 예측하고 넣었기 때문에 4번의 비교를 한다.  
1: [9, 5]  
2: [9, 5, 34]  
3: [9, 5, 34, 3]  
4: [9, 5, 34, 3, 30]  
이렇게해서 9534330이 나온다.

위의 경우는 String 타입의 조건으로 정렬은 한 경우이며, 같은 타입의 인스턴스 끼리도 비교가 가능하다.  
이는 java util 함수내부에서 최적의 조건으로 정렬하는 것이라 생각된다.
